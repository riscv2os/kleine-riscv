### 7. **資料危障與冒險處理**

在現代處理器設計中，流水線技術是提升指令執行效率的重要手段。然而，這種技術也帶來了一些挑戰，特別是資料冒險（data hazard）、控制冒險（control hazard）和結構冒險（structural hazard）。這些冒險可能會導致處理器執行的指令順序錯亂，甚至造成錯誤的運算結果。因此，設計高效的冒險處理機制是確保流水線處理器性能的關鍵。

#### 資料冒險

**定義**：資料冒險發生在一條指令需要依賴另一條指令的結果，而該結果尚未被計算或寫回寄存器的情況下。這種情況常見於兩條指令之間存在數據依賴關係。例如：

```assembly
ADD R1, R2, R3   ; R1 = R2 + R3
SUB R4, R1, R5   ; R4 = R1 - R5 (依賴於第一條指令的結果)
```

在這個例子中，第二條指令在第一條指令的結果尚未可用時就被取出，將導致錯誤的運算結果。

**Kleine-RISC-V 的處理機制**：
1. **停頓（Stalling）**：當資料冒險被檢測到時，Kleine-RISC-V 可以暫停取指和解碼階段。這樣做的目的是等待依賴的指令完成執行，確保後續指令可以獲得正確的數據。這種方法雖然有效，但會造成流水線的效率下降，因為處理器必須停頓。

2. **旁路（Bypassing）**：為了減少停頓帶來的性能損失，Kleine-RISC-V 實現了旁路技術。這意味著，如果一條指令在 ALU 執行完畢後，直接將結果傳遞給後續需要該結果的指令，而不必等到結果寫回寄存器。旁路機制能有效減少資料冒險的影響，提高指令的執行效率。

3. **數據冒險檢測**：Kleine-RISC-V 內部的控制邏輯負責檢測資料冒險。控制單元會根據解碼階段的信息（如寄存器地址）來確定是否存在冒險，並根據需要生成相應的停頓信號或旁路控制信號。

以下是 `hazard.v` 模組的部分程式碼，用於實現資料冒險檢測：

```verilog
assign data_hazard = valid_decode && ( // 若解碼有效
    (valid_execute && rd_address_execute != 0 && ( // 若執行有效且目標寄存器不為 0
        uses_rs1 && rs1_address_decode == rd_address_execute // 使用 rs1 且地址匹配
        || uses_rs2 && rs2_address_decode == rd_address_execute // 使用 rs2 且地址匹配
    ))
    || (valid_memory && rd_address_memory != 0 && !bypass_memory && ( // 若記憶體有效且目標寄存器不為 0 且不進行旁路
        uses_rs1 && rs1_address_decode == rd_address_memory // 使用 rs1 且地址匹配
        || uses_rs2 && rs2_address_decode == rd_address_memory // 使用 rs2 且地址匹配
    ))
    || uses_csr && ( // 若使用 CSR
        csr_write_execute && valid_execute // 若執行有效且寫入 CSR
        || csr_write_memory && valid_memory // 若記憶體有效且寫入 CSR
        || csr_write_writeback && valid_writeback // 若回寫有效且寫入 CSR
    )
);
```

在這段程式碼中，我們檢查解碼階段是否有效，然後判斷在執行階段和記憶體階段的指令是否會影響到當前解碼的指令。這樣的邏輯幫助我們有效地檢測到可能的資料冒險。

#### 控制冒險

**定義**：控制冒險發生在遇到分支指令時。分支指令會改變程序的執行流，因此在確定下一條指令的取指地址之前，處理器需要確定分支的執行結果。如果處理器在尚未知道分支結果的情況下就取指，將可能導致錯誤的指令被載入。

**Kleine-RISC-V 的處理機制**：
1. **分支預測**：Kleine-RISC-V 使用分支預測技術來最小化控制冒險的影響。這一技術通過跟蹤過去的執行行為來預測分支的結果。若預測成功，則可以無縫地繼續取指；若預測失敗，則必須清除流水線並重新取指，這會造成性能損失。

2. **失效機制**：當發現分支需要進行實際計算時，Kleine-RISC-V 會使取指和解碼階段失效。這意味著當前指令的取指和解碼將被撤回，直到能夠確定下一條指令的正確地址。這一機制確保了在處理分支時能夠正確執行指令。

3. **硬體支持**：控制單元能根據當前指令的類型來啟用或禁用分支預測和失效機制，從而動態調整處理器的行為以應對不同的情況。

以下是控制冒險失效信號的計算方式：

```verilog
assign invalidate_fetch = reset || branch_invalidate || (!fetch_ready && !data_hazard); // 若重置、發生分支或取指未準備好且存在資料冒險則失效
```

在這段程式碼中，取指失效信號會考慮到重置信號、分支無效信號以及取指是否準備好等因素，這樣的設計能夠確保處理器在遇到控制冒險時能正確應對。

#### 結構冒險

**定義**：結構冒險是由於硬體資源的競爭而產生的冒險。例如，若兩條指令同時需要訪問 ALU，且該 ALU 只有一個時，則可能出現結構冒險。這種冒險通常與硬體設計的資源配置有關。

**Kleine-RISC-V 的處理機制**：
1. **資源共享**：Kleine-RISC-V 在設計時考慮了資源的合理共享。處理器可以在設計上避免同一時間需要訪問相同硬體資源的情況，以減少結構冒險的發生。

2. **停頓機制**：若結構冒險無法避免，Kleine-RISC-V 會根據需要停頓相應的階段，確保所需的資源在執行時可用。這可能導致某些階段被迫停頓，從而影響指令流的順暢性。

3. **優先級管理**：Kleine-RISC-V 的設計中會考慮各種操作的優先級，以確保更重要的操作可以優先獲取資源，這樣可以減少結構冒險對性能的影響。

以下是與結構冒險相關的程式碼片段，主要用於控制資源的使用：

```verilog
assign stall_memory = wfi; // 若執行 wfi，則記憶體階段停頓
```

這段程式碼指示當處於等待中斷狀態時，記憶體階段必須停頓，這有助於避免由於資源競爭導致的結構冒險。

### 小結

在 Kleine-RISC-V 的設計中，資料冒險、控制冒險和結構冒險的處理機制是互相配合的，以確保處理器能夠高效且正確地執行指令。透過停頓、旁路、分支預測和資源管理等技術，Kleine-RISC-V 減少了冒險帶來的影響，從而提高了整體的執行效率和穩定性。這些冒險處理機制不僅是現代處理器