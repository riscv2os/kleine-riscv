### 第 5 章：控制單元

控制單元是處理器中負責協調數據流、操作和資源使用的核心模塊之一。在這一章，我們將探討控制單元的作用，並討論控制信號如何在 5 級流水線中被運用來實現正確的指令執行。

---

#### 控制單元在處理器中的作用

**控制單元** 是處理器中的指令管理核心，負責根據每條指令的操作碼來生成相應的控制信號，這些控制信號將驅動其他模塊（如 ALU、寄存器文件、數據存儲器等）執行正確的操作。

具體來說，控制單元的主要作用包括：
1. **解碼指令**：將來自指令存儲器的指令進行解碼，識別指令類型。
2. **生成控制信號**：根據指令類型生成相應的控制信號，以便在 ALU、寄存器文件、數據存儲器等模塊中執行正確的操作。
3. **協調資源**：確保不同的硬件模塊在正確的時序下運行，避免競爭和衝突。
4. **流水線協調**：在處理器的流水線結構中，控制單元還需負責協調指令的執行順序和處理流程，避免數據冒險和控制冒險。

---

#### RISC-V 的控制邏輯

**RISC-V** 的控制單元是基於指令操作碼的解碼器，主要作用是根據指令的操作碼和功能碼來生成適當的控制信號。這些信號將驅動 ALU、寄存器文件、數據存儲器等模塊來執行對應的操作。

##### 控制信號類型：

1. **ALU 控制信號**：這些信號告訴 ALU 應該執行何種運算操作，如加法、減法、邏輯運算等。
2. **寄存器文件控制信號**：控制哪個寄存器作為源操作數，以及運算結果應寫回哪個寄存器。
3. **數據存儲控制信號**：決定是否從內存加載數據或將數據寫入內存。
4. **分支控制信號**：控制分支指令的執行流程，確保程序跳轉到正確的指令地址。
5. **流水線控制信號**：協調不同流水線階段之間的數據傳遞，避免數據冒險和控制冒險。

##### RISC-V 的控制單元設計

RISC-V 的控制單元是一個簡單的組合邏輯模塊，它的輸入是來自指令的操作碼和功能碼，輸出是對應的控制信號。其結構如下：

- **輸入**：從解碼階段來的指令操作碼（opcode）和功能碼（funct3 和 funct7）。
- **輸出**：對應的控制信號，如 `alu_ctrl`（控制 ALU 的操作）、`mem_read`（控制內存讀取）、`reg_write`（控制寄存器寫入）等。

以下是控制單元的基本控制邏輯的 Verilog 實現示例： （kleine 的實作分散在程式中，以下非 kleine 的實作，但可以幫助理解整體邏輯）

```verilog
module control_unit (
    input [6:0] opcode,
    input [2:0] funct3,
    input [6:0] funct7,
    output reg [2:0] alu_ctrl,
    output reg mem_read,
    output reg mem_write,
    output reg reg_write,
    output reg branch
);

always @(*) begin
    case (opcode)
        7'b0110011: begin  // R-type
            reg_write = 1;
            mem_read = 0;
            mem_write = 0;
            branch = 0;
            case (funct3)
                3'b000: alu_ctrl = (funct7 == 7'b0000000) ? 3'b000 : 3'b001;  // ADD or SUB
                3'b111: alu_ctrl = 3'b111;  // AND
                3'b110: alu_ctrl = 3'b110;  // OR
                default: alu_ctrl = 3'b000;
            endcase
        end
        7'b0000011: begin  // Load
            reg_write = 1;
            mem_read = 1;
            mem_write = 0;
            branch = 0;
            alu_ctrl = 3'b000;  // ADD for address calculation
        end
        7'b0100011: begin  // Store
            reg_write = 0;
            mem_read = 0;
            mem_write = 1;
            branch = 0;
            alu_ctrl = 3'b000;  // ADD for address calculation
        end
        7'b1100011: begin  // Branch
            reg_write = 0;
            mem_read = 0;
            mem_write = 0;
            branch = 1;
            alu_ctrl = 3'b001;  // SUB for comparison
        end
        default: begin
            reg_write = 0;
            mem_read = 0;
            mem_write = 0;
            branch = 0;
            alu_ctrl = 3'b000;
        end
    endcase
end

endmodule
```

這段代碼展示了控制單元根據指令操作碼生成不同控制信號的過程。

---

#### 流水線中的控制信號

**控制信號** 在處理器的 **流水線結構** 中扮演了關鍵角色，它們在不同階段傳遞，指導各模塊如何處理數據並協同工作。

在 RISC-V 的 5 級流水線中，控制信號主要貫穿以下幾個階段：
1. **取指階段（IF）**：控制信號決定從哪裡取指令（普通取指或分支跳轉）。
2. **解碼階段（ID）**：控制單元根據操作碼生成控制信號，指示下一階段應如何處理操作數。
3. **執行階段（EX）**：控制信號指導 ALU 執行正確的算術或邏輯運算。
4. **存取階段（MEM）**：控制信號決定是否要從內存中讀取或寫入數據。
5. **回寫階段（WB）**：控制信號決定 ALU 或內存的結果是否應寫回寄存器文件。

##### 流水線控制信號的傳遞

流水線控制信號的設計需要考慮多級模塊之間的協作和同步，尤其是當涉及分支跳轉、數據冒險等情況時，控制信號的處理變得更加複雜。例如：
- **分支控制信號**：在執行階段生成的分支跳轉信號需要傳回取指階段，更新下一條指令的地址。
- **數據冒險處理信號**：當運行指令的結果尚未生成且其他指令已經進入流水線時，需要插入冒險處理信號來阻止數據衝突。

這些控制信號在流水線內部和跨階段的傳遞，對於保證處理器的高效運行至關重要。

---

### 小結

在這一章中，我們詳細介紹了 **RISC-V** 中 **控制單元** 的設計與實現。控制單元是處理器的核心模塊，負責解碼指令並生成相應的控制信號來驅動其他模塊。通過對 RISC-V 控制邏輯和流水線控制信號的探討，我們能夠更好地理解處理器內部的協同運作原理，這對於學習和設計處理器架構至關重要。